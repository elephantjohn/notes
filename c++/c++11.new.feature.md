
## 1. Lamda express

 A lambda expression has the form:

```c++
[capture](parameters)->return-type {body}
```

`for_each()` to traverses a char array

```c++
int main()

{

   char s[]="Hello World!";

   int Uppercase = 0; //modified by the lambda

   for_each(s, s+sizeof(s), [&Uppercase] (char c) {

    if (isupper(c))

     Uppercase++;

    });

 cout<< Uppercase<<" uppercase letters in: "<< s<<endl;

}
```





# 2. Automatic type

```c++
auto x=0; //x has type int because 0 is int

auto c='a'; //char

auto d=0.5; //double

auto national_debt=14400000000000LL;//long long
```



# 3.Uniform Initialization Syntax

无论是类的变量，数组，stl的容器，类的构造，都统一使用{}，以后只要是初始化就首先考虑{}的初始化

```c++
class test{
    int a ,b,c[4];
    int *d = new int[3]{1,2,3,4};//C++ 11提供的独有的初始化方式
    vector<int> vec = {1,2,3}; //c++ 11 独有的
    map<string, int> _map = {{"hello",1},{"world",2}};//c++ 11 独有的
public:
    test(int i ,int j):a(i),b(j),c{2,3,4,2}{};
};
 
int main(int argc, const char * argv[])
{
    
    test t{1,2};//初始化test类
    return 0;
}

class C
{
int a;
int b;
public:
 C(int i, int j);
};
C c {0,0}; //C++11 only. Equivalent to: C c(0,0);
int* a = new int[3] { 1, 2, 0 }; /C++11 only
class X {
  int a[4];
public:
  X() : a{1,2,3,4} {} //C++11, member array initializer
};
```





# 4. nullptr

`nullptr` is strongly-typed

```c++
void f(int); //#1
void f(char *);//#2

//C++03
f(0); //which f is called?

//C++11
f(nullptr) //unambiguous, calls #2
```



#  5.Threading Library

std::future,

std::shared_future,

std::promise,

see videos:

> https://www.youtube.com/watch?v=SZQ6-pf-5Us



## std::future<>

>  __trans value from child thread to parent thread__



### eg1  std::launch::deferred

```c++
#include <future>
#include <iostream>

using namespace std;
 
int factorial2(int N)
 {
    int res = 1;

    for(int i=N; i>1; i--)
        res *= i;
    
    cout << "Result is:" << res << endl;
    return res;
 }

  int main()
 {
    int x;
    
    std::future<int> fu = std::async(std::launch::deferred, factorial2, 4);

    x = fu.get();
    //fu.get(); crash. because fu can only call get() once.

    return 0;
 }
```

> std::launch::deferred means: when fu.get() called, then factorial2() will execute ,and they are in the same thread.



### eg2. std::launch::async

```c++
#include <future>
#include <iostream>

using namespace std;
 
int factorial2(int N)
 {
    int res = 1;

    for(int i=N; i>1; i--)
        res *= i;

    return res;
 }
 
int main()
 {
    int x;
    
    std::future<int> fu = std::async(std::launch::async, factorial2,4);

    x = fu.get();

    return 0;
 }
```

> std::launch::async means: a new thread will be create to execute function.
>
> if you very sure there should be a new thread to execute the function, they will be" std::launch::async"



### eg3.  std::launch::deferred | std::launch::async

> std::launch::deferred | std::launch::async means ,whether to create a new thread or not,rely on the implementation. if you very sure there should be a new thread to execute function, you use "std::launch::async" rather than "std::launch::deferred | std::launch::async ".
>
> the default param is " std::launch::deferred | std::launch::async" 

```c++
#include <future>
#include <iostream>

using namespace std;

int factorial2(int N)
 {
    int res = 1;

    for(int i=N; i>1; i--)
        res *= i;
    
    return res;
 }
 
    int main()
 {
    int x;
    
    //std::future<int> fu = std::async(factorial2,4);// the same as below,the default is "std::launch::deferred|std::launch::async"
    std::future<int> fu = std::async(std::launch::deferred|std::launch::async|factorial2,4);//the same as above, the 

    x = fu.get();

    return 0;
 }

```

##  std::future<> + std::promise<>   

> __trans value from parant thread to child thread.__



### eg1. std::future<> + std::promise

```c++
#include <future>
#include <iostream>

using namespace std;

 int factorial(std::future<int>& f)
 {
    int res = 1;
    
    int N = f.get();
    for(int i=N; i>1; i--)
        res *= i;
    
    cout << "Result is:" << res << endl;
    return res;
 }
 
 int main()
 {
    int x;
    std::promise<int> p;
    std::future<int> f = p.get_future();

    std::future<int> fu = std::async(std::launch::async, factorial, std::ref(f));

    //do something else
    std::this_thread::sleep_for(chrono::milliseconds(20));
    p.set_value(4);

    x = fu.get();
    cout << "Get from child: " << x << endl;
    return 0;
 }

the output is:
Result is:24
Get from child: 24
```

### eg2. breaking-promise

> __if i realy cant set promise,there will be a breaking-promise__



```
#include <future>
#include <iostream>

using namespace std;

 int factorial(std::future<int>& f)
 {
    int res = 1;
    
    int N = f.get();
    for(int i=N; i>1; i--)
        res *= i;
    
    cout << "Result is:" << res << endl;
    return res;
 }
 
int main()
 {
    int x;
    std::promise<int> p;
    std::future<int> f = p.get_future();

    std::future<int> fu = std::async(std::launch::async, factorial, std::ref(f));

    //do something else
    std::this_thread::sleep_for(chrono::milliseconds(20));

    p.set_exception(std::make_exception_ptr(std::runtime_error("To err is human"))); // if i realy cant set value to a promise
    // p.set_value(4);

    x = fu.get();
    cout << "Get from child: " << x << endl;
    return 0;
 }
```



### eg3. trans value to future/promise

> promise/future can only be moved, not copied.

```c++
 std::promise<int> p;
 //std::promise<int> p2 = p;//error
 std::promise<int> p2 = std::move(p);//ok
```



## shared_future

```c++
 int factorial3(std::shared_future<int> f )// the f is not refernce(&f)
 {
    int res = 1;
    
    int N = f.get();
    for(int i=N; i>1; i--)
        res *= i;
    
    cout << "Result is:" << res << endl;
    return res;
 }
 
int main()
 {
    int x;
    std::promise<int> p;
   
    std::future<int> f = p.get_future();
    std::shared_future<int> sf = f.share();

    std::future<int> fu = std::async(std::launch::async, factorial3, sf);
    std::future<int> fu2 = std::async(std::launch::async, factorial3, sf);
    std::future<int> fu3 = std::async(std::launch::async, factorial3, sf);
    std::future<int> fu4 = std::async(std::launch::async, factorial3, sf);
    //... 10 threads

    p.set_value(4);
  
    return 0;
 }

the output is:
(1)
Result is:Result is:Result is:24Result is:24

24
24

(2)
Result is:Result is:24
Result is:24
Result is:24
24   
    
(3)
Result is:Result is:24
24
Result is:24
Result is:24
    
(4)
(5) ....
```





# 6. New Smart Pointer Classes



# 7.New C++ Algorithms

